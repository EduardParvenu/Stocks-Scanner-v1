<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Scanner V2</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 10px; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #90EE90; } /* Mild green headers */
        .green { color: green; }
        .red { color: red; }
        button { padding: 10px 20px; margin: 5px; background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #45a049; }
        #timer { font-weight: bold; }
        #futuresTracker p { display: inline-block; margin-right: 20px; }
    </style>
</head>
<body>
    <h1>Stock Scanner V2</h1>
    <!-- Futures Tracker Section -->
    <div id="futuresTracker">
        <p>Dow: <span id="YM-change">Loading...</span></p>
        <p>S&P 500: <span id="ES-change">Loading...</span></p>
        <p>NASDAQ: <span id="NQ-change">Loading...</span></p>
        <p>VIX: <span id="VIX-change">Loading...</span></p>
        <p>Russell 2000: <span id="RTY-change">Loading...</span></p>
    </div>
    <!-- Control Buttons and Timer -->
    <button id="startBtn">Start Scanner</button>
    <button id="pauseBtn" style="display:none;">Pause Scanner</button>
    <p id="timer">Scanner not running</p>
    <!-- Stock Table -->
    <table id="stockTable">
        <thead>
            <tr>
                <th>Symbol</th>
                <th>% Change</th>
                <th>RSI</th>
                <th>MACD</th>
                <th>News Headline</th>
                <th>Movement Strength</th>
                <th>Duration Potential</th>
                <th>Warning</th>
            </tr>
        </thead>
        <tbody id="tableBody">
            <tr><td colspan="8">Scanner not started. Click 'Start' to begin.</td></tr>
        </tbody>
    </table>

    <script>
        // Global Variables
        let tiingoKey = '';
        const finnhubKey = 'cv9nin9r01qpd9s89t80cv9nin9r01qpd9s89t8g'; // Replace with your Finnhub API key
        // Sample pool of potential stocks (expand to 200 mid-cap and large-cap tickers)
        const potentialStocks = [
            "AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "META", "NVDA", "JPM", "V", "DIS",
            "PYPL", "NFLX", "ADBE", "CSCO", "INTC", "PEP", "KO", "PFE", "MRK", "T"
        ];
        let bucketList = []; // Dynamic list of 25 oversold stocks
        let stockData = {}; // Stores RSI, MACD, etc., for bucket list stocks
        let scannerInterval, bucketInterval, futuresInterval, timerInterval;
        let scannerCountdown = 30; // Dashboard refresh every 30 seconds

        // DOM Elements
        const tableBody = document.getElementById('tableBody');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const timerDisplay = document.getElementById('timer');

        // Fetch Tiingo data (for stocks/ETFs only) with delay to manage rate limits
        async function fetchTiingo(endpoint, delayMs) {
            try {
                const response = await fetch(`https://api.tiingo.com${endpoint}&token=${tiingoKey}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                await new Promise(resolve => setTimeout(resolve, delayMs));
                return data;
            } catch (error) {
                console.error(`Error fetching Tiingo data: ${error}`);
                return null;
            }
        }

        // Fetch Finnhub futures data (isolated from stock data)
        async function fetchFuturesData() {
            const futures = [
                { symbol: 'YM', name: 'Dow' },
                { symbol: 'ES', name: 'S&P 500' },
                { symbol: 'NQ', name: 'NASDAQ' },
                { symbol: 'VIX', name: 'VIX' },
                { symbol: 'RTY', name: 'Russell 2000' }
            ];
            for (const { symbol, name } of futures) {
                try {
                    const response = await fetch(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${finnhubKey}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    const change = data.dp ? data.dp.toFixed(2) : 'N/A';
                    const color = change >= 0 ? 'green' : 'red';
                    document.getElementById(`${symbol}-change`).textContent = change + '%';
                    document.getElementById(`${symbol}-change`).className = color;
                } catch (error) {
                    console.error(`Error fetching futures data for ${name}: ${error}`);
                    document.getElementById(`${symbol}-change`).textContent = 'Unavailable';
                    document.getElementById(`${symbol}-change`).className = '';
                }
            }
        }

        // Update bucket list dynamically every 10 minutes
        async function updateBucketList() {
            const batchSize = 10;
            const historicalData = {};
            const startDate = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            // Fetch 14 days of historical data in batches
            for (let i = 0; i < potentialStocks.length; i += batchSize) {
                const batch = potentialStocks.slice(i, i + batchSize).join(',');
                const data = await fetchTiingo(`/tiingo/daily/prices?tickers=${batch}&startDate=${startDate}`, 5000);
                if (data) {
                    for (const item of data) {
                        const symbol = item.ticker;
                        if (!historicalData[symbol]) historicalData[symbol] = [];
                        historicalData[symbol].push(item.close);
                    }
                }
            }
            // Calculate RSI and filter oversold stocks (RSI < 30)
            const rsiData = {};
            for (const [symbol, prices] of Object.entries(historicalData)) {
                const rsi = calculateRSI(prices);
                if (rsi < 30) {
                    rsiData[symbol] = rsi;
                }
            }
            // Sort by RSI (ascending) and select top 25
            const sortedStocks = Object.entries(rsiData).sort((a, b) => a[1] - b[1]);
            bucketList = sortedStocks.slice(0, 25).map(([symbol]) => symbol);
            if (bucketList.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="8">No oversold stocks found.</td></tr>';
            } else {
                // Store RSI and MACD for bucket list stocks
                bucketList.forEach(symbol => {
                    const prices = historicalData[symbol];
                    stockData[symbol] = {
                        rsi: calculateRSI(prices),
                        macd: calculateMACD(prices)
                    };
                });
            }
        }

        // Placeholder for RSI calculation
        function calculateRSI(prices) {
            // TODO: Implement actual RSI calculation using the last 14 closing prices
            // For now, returns a random value for testing
            return Math.random() * 100;
        }

        // Placeholder for MACD calculation
        function calculateMACD(prices) {
            // TODO: Implement actual MACD calculation using historical prices
            // For now, returns a random value for testing
            return Math.random() * 2 - 1;
        }

        // Update scanner dashboard every 30 seconds
        async function updateScanner() {
            if (bucketList.length === 0) return;
            const quotes = await fetchQuotes(bucketList);
            const newsList = await fetchNews(bucketList);
            const top5 = selectTop5(quotes, newsList);
            renderTable(top5, quotes, newsList);
        }

        // Fetch latest quotes for bucket list stocks
        async function fetchQuotes(symbols) {
            const quotes = {};
            for (const symbol of symbols) {
                const data = await fetchTiingo(`/tiingo/daily/${symbol}/prices`, 5000);
                if (data) quotes[symbol] = data[0]; // Latest trading day data
            }
            return quotes;
        }

        // Fetch latest news for bucket list stocks
        async function fetchNews(symbols) {
            const newsList = {};
            for (const symbol of symbols) {
                const data = await fetchTiingo(`/tiingo/news?tickers=${symbol}`, 5000);
                if (data && data.length > 0) newsList[symbol] = data[0].title;
            }
            return newsList;
        }

        // Select top 5 stocks based on a simple scoring mechanism
        function selectTop5(quotes, newsList) {
            const scoredStocks = bucketList.map(symbol => {
                const quote = quotes[symbol];
                const news = newsList[symbol];
                const percentChange = quote ? ((quote.close - quote.open) / quote.open * 100).toFixed(2) : 0;
                const rsi = stockData[symbol].rsi;
                const score = parseFloat(percentChange) + (30 - rsi); // Higher % change and lower RSI = better score
                return { symbol, score, percentChange };
            });
            scoredStocks.sort((a, b) => b.score - a.score);
            return scoredStocks.slice(0, 5).map(stock => stock.symbol);
        }

        // Render the table with the top 5 stocks
        function renderTable(top5, quotes, newsList) {
            tableBody.innerHTML = '';
            if (top5.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="8">No data available</td></tr>';
                return;
            }
            top5.forEach(symbol => {
                const quote = quotes[symbol];
                const news = newsList[symbol];
                const percentChange = quote ? ((quote.close - quote.open) / quote.open * 100).toFixed(2) : 'N/A';
                const rsi = stockData[symbol].rsi;
                const macd = stockData[symbol].macd;
                const warning = rsi > 70 ? 'Overbought Risk' : '';
                const row = `<tr>
                    <td>${symbol}</td>
                    <td>${percentChange}%</td>
                    <td>${rsi.toFixed(2)}</td>
                    <td>${macd.toFixed(2)}</td>
                    <td>${news || 'No news'}</td>
                    <td>Moderate</td> <!-- Placeholder for movement strength -->
                    <td>Hours</td> <!-- Placeholder for duration potential -->
                    <td>${warning}</td>
                </tr>`;
                tableBody.innerHTML += row;
            });
        }

        // Start Scanner Event Listener
        startBtn.addEventListener('click', () => {
            tiingoKey = prompt('Enter your Tiingo API key:');
            if (!tiingoKey) return;
            startBtn.style.display = 'none';
            pauseBtn.style.display = 'inline-block';
            tableBody.innerHTML = '<tr><td colspan="8">Loading...</td></tr>';
            updateBucketList().then(updateScanner);
            fetchFuturesData();
            bucketInterval = setInterval(updateBucketList, 10 * 60 * 1000); // 10 minutes
            scannerInterval = setInterval(updateScanner, 30 * 1000); // 30 seconds
            futuresInterval = setInterval(fetchFuturesData, 5 * 60 * 1000); // 5 minutes
            timerInterval = setInterval(updateTimer, 1000);
            scannerCountdown = 30;
        });

        // Pause Scanner Event Listener
        pauseBtn.addEventListener('click', () => {
            clearInterval(bucketInterval);
            clearInterval(scannerInterval);
            clearInterval(futuresInterval);
            clearInterval(timerInterval);
            tiingoKey = '';
            startBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'none';
            timerDisplay.textContent = 'Scanner paused';
            tableBody.innerHTML = '<tr><td colspan="8">Scanner paused. Click "Start" to resume.</td></tr>';
        });

        // Update countdown timer
        function updateTimer() {
            if (scannerCountdown > 0) {
                scannerCountdown--;
                timerDisplay.textContent = `Next update in ${scannerCountdown} seconds`;
            } else {
                scannerCountdown = 30;
            }
        }

        // Initial state
        timerDisplay.textContent = 'Scanner not running';
    </script>
</body>
</html>
